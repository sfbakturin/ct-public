# [I. Декомпозиция](I.cpp)

| Ограничения                                 |
|:-------------------------------------------:|
| ограничение по времени на тест: 2 секунды   |
| ограничение по памяти на тест: 256 мегабайт |
| входной файл: `стандартный ввод`            |
| выходной файл: `стандартный вывод`          |

## Условие

Рассмотрим дерево $T$. Назовем деревом декомпозиции корневое дерево $D(T)$.

Выберем любую из вершин дерева $T$, назовем ее $r$. Рассмотрим все компоненты связности дерева $T$, после удаления вершины $r$: $S_1, ~ S_2, ~ \ldots, ~ S_k$. Тогда корнем $D(T)$ будет вершина $r$, а детьми $r$ в $D(T)$ будут $D(S_1), ~ D(S_2), ~ \ldots, ~ D(S_k)$.

Вам задано T. Найдите дерево декомпозиции, высота которого не более $20$. Высотой дерева называется максимальное число вершин, которые может содержать простой путь начинающийся в корне.

## Входные данные

Первая строка содержит $n$ — число вершин дерева $T$ $(1 \leqslant n \leqslant 2 \cdot 10^5)$.

Следующие $n - 1$ строк содержат ребра дерева. Каждое ребро описывается парой чисел $v_i$, $u_i$ — концы ребра $(1 \leqslant v_i, u_i \leqslant n)$.

## Выходные данные

Выведите $n$ чисел: $i$-е число — родитель вершины $i$ в дереве декомпозиции, если вершина является корнем, выведите $0$.

## Примеры

**входные данные**:

```text
3
1 2
2 3
```

**выходные данные**:

```text
2 0 2
```

**входные данные**:

```text
9
3 2
4 2
1 2
5 1
1 6
7 6
6 8
8 9
```

**выходные данные**:

```text
0 1 2 2 1 1 6 6 8
```
